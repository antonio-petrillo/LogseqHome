* #networking, #protocol, #todo
* Transmission Control Protocol
Reliable Data Transfer
* Multiplexing and Demultiplexing
** Is more complicated
TCP use more sophisticated approach than the one described in [[transport layer]].
This because of how the TCP work, just think about the connection, when a TCP connection is established it create a new socket on which the client can communicate.
Hence IT need more information.
** Parameter used
Other than the ~source port~ and the ~destination port~ it bundle also the ~source IP~ and ~destination IP~.
With this information extra TCP can distinguish the request and redirect to the correct socket, (basically the host must have a [[map]] of the connections)
* TCP Connection
TCP is ~connection oriented~ hence when 2 host want to communicate they need first to establish a connection.
This connection lives only on the 2 host, the layer below the [[transport layer]] don't know nothing about TCP, they just receive and send datagram.
TCP is a ~full duplex service~.
TCP is a ~Point to Point~ connection, it happen only between 2 hosts, a multicast communication is not possible with TCP.
* Buffers
[[../assets/tcp_buffers.png]]
* #TODO Three-way Handshake
TCP perform a three-way handshake to initialize a connection.
* Maximum Segment Size (MSS)
Is the size used for a segment there are multiple approach, the most common is the follwing.
Take the MTU (Maximum Transmission Unit, it come from [[network layer]] ), it is the size of a IP datagram, typically ~1500 bytes~ and remove from it the space for the IP headers, ~40 bytes~, this means that, usually,  the MSS is ~1460 bytes~.
In this ~1460 bytes~ we should put all the TCP header and also the the data from the [[application layer]].
Other approach try to compute the size of the largest IP datagram that can surf the network but it is less used.
* Structure of TCP segment
** TCP segment
It is formed by the data (from or directed to the [[application layer]]) encapsulated in a TCP header.
** Data to large
When the data from [[application layer]] is to large, TCP slits it in multiple segment and then recompose it on the other side of the connection, always from TCP.
** TCP header
It use ~20 bytes~ for the header, instead of [[UDP]] which use ~8 bytes~.
*** Structure
:PROPERTIES:
:id: 6384c27e-ae0a-458a-b685-89439023e26d
:END:
[[../assets/tcp_header.png]]
*** Source port & Dest port
They are used for multiplexing and demultiplexing.
*** Internet Checksum
Detect if the segment is corrupted or not.
*** Sequence number & Acknowledgment number
:PROPERTIES:
:id: 6384c34d-6bed-4930-af71-c6a19c841ae2
:END:
Both are of ~16 bit~ (~2 bytes~).
They are used to create a reliable data transfer, see ((6384ad9d-7872-40af-87f3-a253a10b54db)).
*** Receive Window
Used for the ~flow control~, it is ~16 bit~ long.
Point out the number  of bytes the receiver would accept.
*** Header length
TCP segments have a variable length, the header length, of ~4 bit~ specify the TCP header length with ~multiple of 32 bit~.
The length of the header is variable because there is the Options field, which is variable, before the data.
Usually the option field is empty, so, the length of a TCP header is, usually, of ~20 bytes~.
*** Flag field
It is the part just after the header length and the beginning of receive window.
This flag are used to identify which kind of operation is required (ACK, SYN, SYN/ACK, FIN, ecc...)
**** Start and end connection
ACK, SYN, RST & FIN are used to start and terminate a connection.
**** CWR & ECE are used for control flow
**** PSH
*** Options field
Is used to hold specific information, like a non standard MSS, or particular timestamp or other stuff like that.