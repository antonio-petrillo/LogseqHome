* #networking, #protocol, #todo
* Transmission Control Protocol
Reliable Data Transfer
* Multiplexing and Demultiplexing
** Is more complicated
TCP use more sophisticated approach than the one described in [[transport layer]].
This because of how the TCP work, just think about the connection, when a TCP connection is established it create a new socket on which the client can communicate.
Hence IT need more information.
** Parameter used
Other than the ~source port~ and the ~destination port~ it bundle also the ~source IP~ and ~destination IP~.
With this information extra TCP can distinguish the request and redirect to the correct socket, (basically the host must have a [[map]] of the connections)
* TCP Connection
TCP is ~connection oriented~ hence when 2 host want to communicate they need first to establish a connection.
This connection lives only on the 2 host, the layer below the [[transport layer]] don't know nothing about TCP, they just receive and send datagram.
TCP is a ~full duplex service~.
TCP is a ~Point to Point~ connection, it happen only between 2 hosts, a multicast communication is not possible with TCP.
* Buffers
[[../assets/tcp_buffers.png]]
* #TODO Three-way Handshake
TCP perform a three-way handshake to initialize a connection.
* Maximum Segment Size (MSS)
Is the size used for a segment there are multiple approach, the most common is the follwing.
Take the MTU (Maximum Transmission Unit, it come from [[network layer]] ), it is the size of a IP datagram, typically ~1500 bytes~ and remove from it the space for the IP headers, ~40 bytes~, this means that, usually,  the MSS is ~1460 bytes~.
In this ~1460 bytes~ we should put all the TCP header and also the the data from the [[application layer]].
Other approach try to compute the size of the largest IP datagram that can surf the network but it is less used.
* Structure of TCP segment
** TCP segment
It is formed by the data (from or directed to the [[application layer]]) encapsulated in a TCP header.
** Data to large
When the data from [[application layer]] is to large, TCP slits it in multiple segment and then recompose it on the other side of the connection, always from TCP.
** TCP header
It use ~20 bytes~ for the header, instead of [[UDP]] which use ~8 bytes~.
*** Structure
:PROPERTIES:
:id: 6384c27e-ae0a-458a-b685-89439023e26d
:END:
[[../assets/tcp_header.png]]
*** Source port & Dest port
They are used for multiplexing and demultiplexing.
*** Internet Checksum
Detect if the segment is corrupted or not.
*** Sequence number & Acknowledgment number
:PROPERTIES:
:id: 6384c34d-6bed-4930-af71-c6a19c841ae2
:END:
Both are of ~16 bit~ (~2 bytes~).
They are used to create a reliable data transfer, see ((6384ad9d-7872-40af-87f3-a253a10b54db)).
*** Receive Window
Used for the ~flow control~, it is ~16 bit~ long.
Point out the number  of bytes the receiver would accept.
*** Header length
TCP segments have a variable length, the header length, of ~4 bit~ specify the TCP header length with ~multiple of 32 bit~.
The length of the header is variable because there is the Options field, which is variable, before the data.
Usually the option field is empty, so, the length of a TCP header is, usually, of ~20 bytes~.
*** Flag field
It is the part just after the header length and the beginning of receive window.
This flag are used to identify which kind of operation is required (ACK, SYN, SYN/ACK, FIN, ecc...)
**** Start and end connection
ACK, SYN, RST & FIN
 Are used to start and terminate a connection.
**** CWR & ECE
Are used for control flow.
**** PSH
 Means that the receiver must push, immediately, the data to the upper level.
**** URG
Means that the segment contains data that the sended has marked as *urgent*.
When this is set the receiver can take the pointer to that urgent data immediately, without need to search the important data in the response, from the field *urgent data pointer*.
**** In practice
+ In practice PSH and URG are not used, this because when a segment contains important data, usually it is all composed by important data and also it's not job of TCP to hide data, hence that data is anyway ~visible | transparent | not encrypted~
*** Options field
Is used to hold specific information, like a non standard MSS, or particular timestamp or other stuff like that.
** Going deep
*** Sequence's number & acknowledgment's number
:LOGBOOK:
CLOCK: [2022-11-29 Tue 10:26:49]--[2022-11-29 Tue 10:26:50] =>  00:00:01
:END:
TCP use the implicit numeration of a stream of byte as sequence number, with this it can understand the order in which they come and reorder them.
For the ACK there is another approach, the next usable ACK in a TCP communication is the lowest number of bytes received + 1.
Here an example, it is more explanatory in this case:
#+BEGIN_EXAMPLE
Host A send 3 TCP segment, say that goes from [0 - 535] bytes (see sequence' number), the second from [536 - 1023] and the third [1024 - 2048].
Now B received the first one ([0 - 535]), to ACK the host A is send the ACK number 536 (535 + 1) so  now A knows that the first segment is received by B.
If A receive an ACK number 1025, it knows that the third segment reached B but it also know that the only one that isn't ACK'D is 537 hence the second segment will be resended.
#+END_EXAMPLE
This protocol is known as ~cumulative acknowledgment~.
**** Example
[[../assets/tcp_sequence_numbers_example.png]]
**** Note
1. In this example I assumed a [[SRP]] in the last part of the example, with [[GBN]] will be a little bit different.
2. Usually the number of the first ACK segment is picked at random (pseudo-random).
*** Timeout and RTT (Round Time Trip)
For each group of segment TCP compute a SampleRTT, the time since one of the segment is given to the [[network layer]] to the time the segment is ACK'd.
The SampleRTT is not computed for the re transmitted segments.
The SampleRTT is different on each computation, hence TCP made an estimation called EstimateRTT.
On each new SampleRTT the EstimateRTT is update in the following way:
$$EstimateRTT = (1 - \alpha)\cdot EstimateRTT + \alpha\cdot SampleRTT $$
It is almost the [[Bayes Theorem]] (more like the mutual exclusion possibilities)!
A common value for $$\alpha$$ is $$0.125$$ aka $$\frac{1}{8}$$
Since SampleRTT is a mean ([[https://en.wikipedia.org/wiki/Moving_average#:~:text=An%20exponential%20moving%20average%20(EMA,decreases%20exponentially%2C%20never%20reaching%20zero.][link]]), we need also a standard deviation, we call it DevRTT (Deviation RTT).
$$DevRTT = (1-\beta)\cdot DevRTT + \beta\cdot \mid SampleRTT - EstimatedRTT \mid$$
A common value for $$\beta$$ is $$0.25$$ aka $$\frac{1}{4}$$.
Compute the timeout:
$$timeout = EstimatedRTT + 4\cdot DevRTT$$
Basically we are asking for value outside of gaussian bell, for abnormal values for the timeout.
An initial value for the ~timeout~ is ~1 second~.
*** Flow Control
The field ~receive window~ tell to the sender the amount of free space in the buffer of the receiver.
Since TCP is ~full duplex~ the ~receive window~ is maintained in both way.
Each buffer keep the following vars:
1. LastByteRead
2. LastByteRcvd
3. RcvBuffer
To avoid buffer overflow we need that $$LastByteRcvd - LastByteRead \leq RcvBuffer$$.
The ~window size~ (~receive window~) is calculated with:
$$rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)$$
This value is used by the sender to understand how many data it can send.
The sender keep also this other vars:
1. LastByteSend
2. LastByteAcked
The difference between this 2 indicates the amount of data sended.
So the sender must ensure that:
$$LastByteSend - LastByteAcked \leq rwnd$$