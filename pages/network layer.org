* #networking, #todo
* Where it lives?
This layer is found in 2 places, the host and the router, this make it a bit hard to understand at first.
Internally it could be divided in *data plane* and *control plane*.
The *control plane* compute a *forwarding table* (generated through *Routing* algos) that will be used by the *data plane* to forward (*forwarding*) the data.
* Introduction
** Overview
[[../assets/network-layer-overview.png]]
** Control and Data plane separation 2 approach
*** Control plane inside the router
[[../assets/control-plane-inside-the-router.jpg]]
*** Control plane on a remote server
[[../assets/control-plane-Software-Defined_Networking_SDN.jpg]]
*** Service model 
:PROPERTIES:
:id: 6391b780-70e0-4704-b235-94fe1087e2e4
:END:
The network layer offer a service called *Best Effort*.
What it guarantees:
1. deliver not guaranteed
2. minimum bandwidth not guaranteed
3. ordered delivery not guaranteed (the packets are delivered in the same order they are sended)
4. it offer encryption services
* What's inside a router
:PROPERTIES:
:collapsed: true
:END:
** For an in depth study see page 255 of [[Computer Networking a Top Down Approach]].
** Overview
As you can evince from the overview, the lower part, input port, output port and switch fabric are implemented in hardware, this is a requirement to reach the maximum speed.
[[../assets/router-architecture-overview.png]]
** Forwarding approachs
*** Generalized forwarding
There are some rule that are used to forward the packet.
I.E. the packet for a google resource must take the first output port and the packet for Microsoft Outlook must go to the third output port.
*** Destination based forwarding
Let me explain with an analogy:
1. before you enter a roundabout there is a road toll booth.
2. before you can proceed you must say at toll booth where you are going 
3. the employee tell you which you have to take in the roundabout
** Input Port
When a packet reach an import port it is routed to the correct output port through the switch fabric using a forwarding table made by the routing processor.
After the first packet of a stream get an output port, a copy of the forwarding table is stored in the input port so the next packets can go faster.
** Switching Fabric
It connect, *physically*, the input port with the output port, basically it's a network (inside another network).
** Output Port
** Routing Processor
Execute the *Control Plane* function, both classic router and SDN operates here.
** Buffers size (input & output)
When a packet cannot be instantly consumed it is stored in a buffer, when this kind of buffers are full the packet is dropped (this what cause packet loss in the upper layers).
So how big the buffers should be?
*** A classical approach suggest:
$Buff Size = RTT\cdot C$, where ~RTT~ is the ~Round Time Trip~ and ~C~ is the ~link capacity~.
*** A more modern study suggest that when there are ~N~ TCP connections:
$BuffSize = RTT\cdot \frac{C}{\sqrt{N}}$
*** Note
+ A  buffer to big will increase the ~queuing time~.
+ A buffer full of TCP connection will have a rough time to free space in the buffer, after an ACK a new packet will come and /re-full/ the buffer.
+ This problem is known as ~bufferbloat~
***
* Packet Scheduling
As always there are more than one solution:
** Good old [[FIFO]] (aka FCFS - First-Come-First-Served)
** Priority Queue
Each packet is label with a priority level.
Each priority class has his own queue, i.e. HTTP has more priority than SSH, SSH more than IMAP and so on.
If the queue is ~not preemptive~ it is not possible to interrupt the forwarding of a packet.
The priority levels and classes are decided by the ISP.
** Round Robin & WFQ
~WRQ := Weighted Fair Queueing~
The packets are divided into class, without a rigid service priority.
Then each class is served round robin style.
[[../assets/wfq.png]]
* IP
** IPv4
The packet at the ~network layer~ is known as ~DATAGRAM~.
*** Datagram Structure
[[../assets/ipv4-datagram.png]]
**** ~Version~ 4 bit
Contains an identifier that allow the router to recognize correctly the datagram.
**** ~Header length~ 4 bit
All the fields of an IPv4 datagram have a fixed length except for the option header which could vary.
Typically an IP datagram doesn't have extra options, this means that usually an IP datagram is 20 bytes long.
**** ~Type of service~ 8 bit
Aka ~TOS~, it's used to distinguish  between datagram that need low latency, i.e. ~VoIP~, or a datagram that don't prioritize latency, like ~FTP~.
~2 bit~ of the TOS are used to explicitly notify the upper layer that there is congestion on the network.
Don't confuse this with the type of protocol used.
**** ~Datagram length~ 16 bit
Total length of the IP datagram, they can vary from 0 (useless!) to 65355 (to big!).
The most common size is ~1500~ (see ((638f4ca9-1e6c-47be-b5c4-68b7dfcfc0f7)) in particular the ~MTU~).
1500 is preferred because it is the maximum size for a ~Ethernet frame~ on the [[link layer]] (the layer below).
**** ~Identifier, Flag & fragmentation offset~ (16 + 3 + 13) bit
[[TODO]]
**** ~TTL~ 8 bit
**** ~Protocol~ 8 bit
This field is used when the datagram reaches the destination.
Specify which protocol should receive the data, for example the value ~6~ specify ~TCP~, ~17~ ~UDP~, and so on (see ~IANA Protocol Numbers 2016~).
**** ~Checksum~ 16 bit
The IP checksum is applied only to the header, essentially is equal to ((63847bd7-3bb8-4a68-abf6-4ff167421a32)) in [[UDP]].
The checksum is computed as ~sum of 1 complement of each 8 byte in the header~, the router that receive the datagram re-compute the checksum an try to match to the stored one.
**** ~Source IP~ & ~Destination IP~
When an host send a datagram it put the destination IP in the ~destination field~ and it's own IP in the ~source field~.
**** ~Options~
Used only on high end router.
**** ~Data~ or ~Payload~
Data from/to the layer above.
In the case of [[TCP]] we have ~20 bytes~ for the IP header and ~20 bytes~ for the [[TCP]] header, hence for the payload we have $MTU - 40 bytes$ (since the MTU is usually ~1500 bytes~ we get that the payload could be, at most ~1460 bytes~).
*** IPv4 routing
** IPv6